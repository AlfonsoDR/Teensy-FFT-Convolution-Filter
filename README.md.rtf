{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;\red0\green128\blue0;\red128\green128\blue128;\red163\green21\blue21;\red0\green77\blue187;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs32\lang9 FFT/Convolution object for Teensy Audio Library\par

\pard\sa200\sl276\slmult1 Brian Millier May 2017\par

\pard\sl276\slmult1\fs24 This object works with the PJRC Teensy Audio library using the Teensy 3.6. I drew upon DD4WH's SDR code in coming up with this library.Thanks Frank.\b\par
\b0  \b Some hardware Floating Point CMSIS routines are used by this object. Teensyduino must have some files replaced/edited to accomodate this.To do this, please follow the detailed instructions found in Post #15 on the Teensy Forum at:\par
{\b0\fs22{\field{\*\fldinst{HYPERLINK https://forum.pjrc.com/threads/40590-Teensy-Convolution-SDR-(Software-Defined-Radio)?highlight=SDR }}{\fldrslt{https://forum.pjrc.com/threads/40590-Teensy-Convolution-SDR-(Software-Defined-Radio)?highlight=SDR\ul0\cf0}}}}\b0\f0\fs22\par
(Ignore item #1, about Si5351, as it doesn't apply here)\par
\tab If you are hesitant about making changes to your Arduino/Teensyduino environment, you can install a second, dedicated Arduino IDE on your PC by downloading the Arduino ZIP file and unzipping it into a new folder, named "Arduino-FPCMSIS" for example. Then run the Teensyduino installer and point to this folder when it asks you for the Arduino IDE location.\par
\par
\fs32 Toolchain used  \fs24 Arduino 1.8.0 and Teensyduino 1.34\fs32\par
\fs22\par
\fs32 What is this good for?\par
\fs24\tab My main goal in writing this was to provide a way for the Teensy to do guitar amplifier cabinet simulation, using commercially available/freeware  impulse files( in WAV format). For this application, the latency (important to guitar players) is approx. 19.5 milliseconds.\par
\fs32\tab\fs24 This can also be used to provide the very sharp filtering characteristics provided by a 513-tap FIR filter.\par
\par
\fs32 How does it work?\par
\fs24\tab This object is a single channel filter which performs a 513-tap convolution on the audio stream that is fed to it (@ 44,100 Hz Sample Rate). Since a 513 tap convolution would require more calculations than a Teensy 3.6 could perform in real time at a 44,100 sample rate, an alternate method is used. When a time domain signal is transformed into the frequency domain, the math-heavy convolution process can be replaced by a  multiplication of the signal and Filter Mask arrays. The combination of the transforms into the frequency domain and back again, plus the array multiplication, turns out to be much quicker than a straight 513-tap convolution (thanks to the efficiency of the FFT routines performed in the CMSIS library).\fs32  \par
\tab\fs24 To use this object, you must first have a 513-tap filter coeficient array. If you are doing standard FIR filtering, you can use the FIR calculation routine found in the FIR_Example sketch included in this github repository ( Thanks to DD4WH for this routine). You pass it the filter center frequency, slope etc. and it fills up a 513 point floating point array. \par
\tab  I wrote this object primarily to do guitar cabinet simulation via convolution. The impulse files that are commonly available to simulate various guitar cabinets are WAV files, with integer coeficients. Therefore, I tailored the FilterConvolution object to accept the filter coeficients in 16-bit integer format. Therefore, in the FIR_example sketch, the floating point FIR array is converted to integer format by multiplying each value by 32768.\par
\tab If you are doing guitar cabinet simulation, you must load the impulse WAV file onto a microSD card, and place it in the socket on the Teensy 3.6 module. If you want to use the Cabinet_Simulation_Example sketch, un-modified, this file should be named MG.wav, as that is the name of the file that I open in this sketch. You can of course modify your sketch to handle any impulse WAV file that you have available- even switching amongst impulse files using switches, for example. \par
\tab I note that the impulse files that I have seen can be very large: 700 KB or greater, even though they only contain 513 actual coeficient values. The rest of the file is padded in zeros. I don't know why they are made this way. Also, since they are WAV format files, they contain header information at the start of the file, and the actual data doesn't always start at any given offset. I search the file from the beginning for the presence of the ID string "data", and then start reading the data 4 bytes beyond that ID (skipping the long integer data size field). I haven't looked at all of the cabinet simulation impulse files that are out there, so if the sketch doesn't work with your file, load it into a hex editor od some sort, and check to see if it follows the standard WAV file format.\par
\tab Whichever way you obtain your filter coeficients, that array must be passed through a 1024 point FFT routine to provide the Filter Mask needed for the FFT/convolution routine.That is done in the sketch as follows:\par
\cf2\f1\fs19 convolution.begin(0);   \cf3 // set to zero to disable audio processing until impulse has been loaded\cf2\par

\pard\sl240\slmult1 convolution.impulse(cabinet_impulse);  \cf3 // generates Filter Mask and enables the audio stream\cf0\f0\fs24  \par
   where \i convolution \i0 is an instance of the AudioFilterConvolution object, and \i cabinet_impulse\i0  is a pointer to a 513 point integer array that has been loaded with the filter coeficients. The actual 513-point Filter Mask is a private array variable within the AudioFilterConvolution class, and is not visible in the example sketch itself.\par
\tab The FFT/convolution filtering is performed in the AudioFilterConvolution.update routine, as is the case for all Audio library objects. To do the 513 point convolution requires 1) a 513 point Filter Mask 2) 512 samples of incoming audio 3) 1024 point FFT, an array multiplication and a 1024 point inverse FFT. However, the Audio library is designed with a block size of 128 audio samples. Therefore, the update routine has to accumulate 4 such blocks before doing the FFT/convolution. It will then operate on those 4 blocks and produce 512 output samples. Each time through the update routine, only one 128 sample block can be sent back into the audio stream. In practice, the update routine maintains a  buffer of input data, operating on the last 512 input samples that have come in, and also maintains a pointer into the 512 sample filter output. It sends out those 512 samples-  128 samples for each invokation of the update routine. \par
\tab There is a pass-through function for this object. In the main sketch this is accessed as follows:\par
\cf1\f1\fs19 void\cf2  loop() \{\par
\tab\cf1 if\cf2  (digitalRead(37) == 0) \{\par
\tab\tab convolution.passThrough(0);\par
\tab\}\par
\tab\cf1 else\cf2\par
\tab\{\par
\tab\tab convolution.passThrough(1);\tab\tab\par
\tab\}\par
\par
\}\par
\par
\f2\lang1033\tab Assuming that Pin 37 has been defined as INPUT_PULLUP, then the filtering will be enabled when the switch is closed, and the audio signal will pass through un-modified when the switch is open.\par
\cf1\f1\lang9\par
\f2\lang1033\tab\cf0 You must add my filter_convolution.h and filter_convolution.cpp files to the folder containing the standard Audio library files. This folder will be located under whatever folder you have installed the Arduino/Teensyduino IDE- modified for FP CMSIS- the path is as follows:\par
\par
c:\\your arduino folder\\hardware\\teensy\\avr\\libraries\\Audio\par
Also, in that folder, edit Audio.h by adding the following line at the end\par
\cf4\f1 #include\cf2  \cf5 "filter_convolution.h"\cf2  \cf3 // library file added by Brian Millier\par
\par
\f2\tab\cf0 Like any custom audio library objects that you add yourself, this one will NOT show up in the Audio System Design Tool found on the PJRC site. Probably the easist way to generate the setup/connection code needed to incorporate this filter into your audio configuration, is to draw your configuration using the Design Tool web program, but place an fir filter. Import this configuration into your sketch. Then, within the \b\i // GUItool: begin automatically generated code\i0  \b0 section replace \par
\cf3\f1\par
\cf0 AudioFilterFIR           fir1;           \par
\par
\f2  with \cf3\par
\f1\par
\cf0\f2 AudioFilterConvolution       convolution;        \par
\cf1\f1\lang9\par
\cf0\f2\lang1033 and, on two AudioConnection lines, replace instances of \i fir1\i0  with \i convolution \par
\par
\i0\tab If you want the convolution filter keywords to be highlighted in orange in the Arduino IDE, like all other Audio library objects, you can add the following line to the \b keywords \b0 file (contained in the Audio folder).\par
\f0\fs24\lang9 AudioFilterConvolution\tab KEYWORD2\par
\par
\tab It is a bit difficult to determine how much of the processor's time is actually being used by this object, due to the way in which it has to process the data. When I placed a \par
\cf6 Serial.println (AudioProcessorUsage()) \par
\cf0 in the loop() section of a sample sketch, it reported 1%  three quarters of the time and 64% about 25% of the time (when it was being printed out once per second).\par
\tab Since the FFT/convolution routine is only being done once for every 4 convolution.update() routine calls, this large variation is probably due to this fact. I think that to provide gapless audio output, one would have to assume that the 64% figure is what must be considered if other Audio objects were to be used in addition to this one.\par
\cf1\f1\fs19\par
}
 